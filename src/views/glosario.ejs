<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<style type="text/css">
body,td,th {
	font-family: "Trebuchet MS", Arial, Helvetica, sans-serif;
}
body {
	background-image: url(fondo_gris_rayos.jpg);
}
.v {
	color: #800000;
}
</style>
</head>

<body>
<h2 align="center"><strong><font color="#742844"> GLOSARIO</font></strong></h2>
<p align="center">&nbsp;</p>
<h1 class="v"><strong>A</strong></h1>
<p><strong>Algoritmo.</strong> Conjunto de Instrucciones que especifican la secuencia  de operaciones a realizar, en orden, para resolver un sistema específico o  clase de problema.</p>
<p><strong>Algoritmos aleatorizados.</strong>  Se dice que un algoritmo está aleatorizado si  su comportamiento es determinado no solo por su entrada, sino por valores  producidos por un generador de números aleatorios random(a, b), que produce un  entero en el rango [a..b] que tiene la misma probabilidad de aparecer que los  otros enteros del rango.<br />
  </p>
<p><strong>Algoritmos ávidos.</strong> Seleccionan  los elementos más prometedores del conjunto de candidatos hasta encontrar una  solución.</p>
<p><strong>Algoritmo determinista.</strong> Es un algoritmo cuyo comportamiento está completamente determinado por su  entrada.</p>
<p><strong>Algoritmo de Monte Carlo.</strong> Con  una alta probabilidad encuentra una solución correcta sea cual sea la entrada. </p>
<p><strong>Algoritmo de las Vegas.</strong> Toma  decisiones al azar para encontrar una solución antes que un algoritmo  determinista.</p>
<p><strong>Algoritmo de Sherwood</strong>. Existe  una solución determinista que es mucho más rápida en media que en el peor caso.</p>
<p><strong>Algoritmos numéricos</strong>. La  solución obtenida es siempre aproximada pero s precisión esperada mejora  aumentado el tiempo de ejecución.</p>
<p><strong>Algoritmos probabilísticos.</strong> Algunos de los pasos de este tipo de algoritmos están en función de valores  pseudoaletorios.</p>
<p><strong>Algoritmos recursivos.</strong> Es aquel  que expresa la solución de un problema en términos de una llamada a sí mismo.</p>
<p><strong>Análisis de algoritmos.</strong> Parte  importante de la Teoría de complejidad computacional más amplia, que provee  estimaciones teóricas para los recursos que necesita cualquier algoritmo que  resuelva un problema computacional dado. </p>
<p><strong></strong></p>
<p>&nbsp;</p>
<h1><strong class="v">B</strong></h1>
<p>  <strong>Bottom-up.</strong> Todos los subproblemas que puedan ser necesarios se resuelven de antemano y  después son usados para resolver las soluciones a problemas mayores. Este  enfoque es ligeramente mejor en consumo de espacio y llamadas a funciones, pero  a veces resulta poco intuitivo encontrar todos los subproblemas necesarios para  resolver un problema dado.</p>
<h1 class="v">nbsp;&</h1>
<h1 class="v">C</h1>
<p><strong>Complejidad computacional.</strong> Es el  tiempo de cálculo y el espacio de memoria requeridos para resolver un  determinado problema.</p>
<p><strong>Complejidad temporal</strong>. Es el  número de pasos que toma resolver una instancia de un problema, a partir del  tamaño de la entrada utilizando el algoritmo más eficiente a disposición.</p>
<p><strong>Complejidad espacial.</strong> Es la  cantidad de memoria que necesita un algoritmo para resolver un problema.</p>
<p><strong>Cota inferior asintótica.</strong> Es la  complejidad temporal mínima requerida por cualquier algoritmo que pueda  aplicarse para resolver un problema.</p>
<p><strong>Cota superior asintótica</strong>. Es una&nbsp;función&nbsp;que  sirve de cota superior de otra función cuando el&nbsp;argumento tiende a  infinito <br />
</p>
<p>&nbsp;</p>
<h1 class="v"><strong>D</strong></h1>
<p><br />
  <strong>Divide y vencerás</strong>. Estrategia de diseño que  divide el problema en subconjuntos disjuntos obteniendo la solución de cada uno  de ellos para después unirlas, logrando así la solución al problema completo.<br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>E</strong></h1>
<p><br />
  <strong>Ecuación de recurrencia.</strong> Es una expresión  finita que define&nbsp;implícitamente una sucesión, en la cual un elemento de  la sucesión se determina por medio de otros elementos más sencillos, que  incluyen casos iniciales o básicos.<br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>F</strong></h1>
<p><br />
  <strong>Fuerza bruta.</strong> Es una técnica que consiste  en enumerar sistemáticamente todos los posibles candidatos para la solución de  un problema, con el fin de encontrar el candidato que satisface la solución al  mismo.<br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>N</strong></h1>
<p><br />
  <strong>Notación asintótica.</strong> Permite representar la  complejidad, y por ende la eficiencia, de un algoritmo, de tal manera que se  puede proyectar el aumento de operaciones requeridas al aumentar el tamaño de  la entrada.&nbsp;<br />
</p>
<p><strong>NP</strong>. La clase de complejidad de los  problemas que pueden ser resueltos en tiempo polinómico calculado a partir de  la entrada por una máquina de Turing no-determinista.<br />
</p>
<p><strong>NP-Completos</strong>. Pueden ser descritos como los  problemas en NP que tienen menos posibilidades de estar en P.<br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>P</strong></h1>
<p><br />
<strong>P.</strong> La clase de complejidad de los problemas  que pueden ser resueltos en tiempo polinómico calculado a partir de la entrada  por una máquina de Turing determinista.</p>
<p><br />
  <strong>Principio de optimalidad.</strong> El principio de  optimalidad de Bellman dicta que &ldquo;dada una secuencia óptima de decisiones, toda  subsecuencia de ella es, a su vez, óptima&rdquo;.<br />
</p>
<p><strong>Programación dinámica.</strong> Intenta resolver  problemas disminuyendo su costo computacional aumentando el costo espacial.<br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>R</strong></h1>
<p><br />
  <strong>Recursividad.</strong> Consiste en funciones que se  llaman a sí mismas, evitando el uso de ciclos y otros iteradores. <br />
</p>
<p><strong>Reductibilidad.</strong>  Es una forma de convertir un problema en otro  problema de tal forma que la solución que se le da al segundo problema pueda  ser usada para resolver el primero.&nbsp; <br />
</p>
<h1 class="v">&nbsp;</h1>
<h1 class="v"><strong>T</strong></h1>
<p><br />
  <strong>Teoría de la complejidad computacional</strong>. Es  la rama de la teoría de la computación que estudia, de manera teórica, los  recursos requeridos durante el cómputo de un algoritmo para resolver un  problema.<br />
  </p>
<p><strong>Tiempo polinomial.</strong> Un algoritmo de tiempo  polinomial es aquel cuya complejidad en el peor caso está acotada por arriba  por un polinomio sobre el tamaño de su entrada.<br />
  </p>
<p><strong>Top-down.</strong> El problema se divide en  subproblemas, y estos subproblemas se resuelven recordando las soluciones en  caso de que sean necesarias nuevamente.Es una combinación de memorización y  recursión.</p>
<p>&nbsp;</p>
<p align="center">&nbsp;</p>
<p align="center">&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 align="center"><strong><font color="#0000FF"> </font color></strong></h2>
<p>&nbsp;</p>
</body>
</html>
